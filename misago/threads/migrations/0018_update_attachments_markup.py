# Generated by Django 4.2.10 on 2025-01-17 21:58
import re
from typing import Optional

from django.conf import settings
from django.db import migrations
from django.db.models import Q


def update_posts_attachments_markup(apps, _):
    Attachment = apps.get_model("misago_attachments", "Attachment")
    Post = apps.get_model("misago_threads", "Post")

    queryset = Post.objects.filter(
        Q(original__contains="/a/")
        | Q(original__contains=settings.MEDIA_URL + "attachments/")
    ).order_by("-id")

    for post in queryset.iterator(chunk_size=20):
        update_post_attachments_markup(Attachment, post)


def update_post_attachments_markup(attachment_type, post):
    original = parse(attachment_type, post.original)
    if original == post.original:
        return False

    post.original = original
    post.save(update_fields=["original"])

    return True


def parse(
    attachment_type,
    source: str,
    from_state: Optional["ParsingState"] = None,
) -> str:
    state = ParsingState(attachment_type, source)

    if from_state:
        state.attachments_ids = from_state.attachments_ids
        state.attachments_paths = from_state.attachments_paths

    while state.pos < state.maximum:
        for rule in RULES:
            if rule(state):
                break

    return state.result


class ParsingState:
    source: str
    maximum: str
    pos: str
    result: str

    def __init__(self, attachment_type, source: str):
        self.attachment_type = attachment_type
        self.attachments_ids: dict = {}
        self.attachments_paths: dict = {}

        self.source = source
        self.maximum = len(source)
        self.pos = 0

        self.result = ""

    def get_attachment(self, *, id: int | None = None, path: str | None = None):
        if id and path:
            raise ValueError("'id' and 'path' options can't be used together")

        if id:
            if id not in self.attachments_ids:
                attachment = self.attachment_type.objects.filter(id=id).first()
                self.attachments_ids[id] = attachment
            return self.attachments_ids[id]

        if path:
            if path not in self.attachments_paths:
                attachment = self.attachment_type.objects.filter(
                    Q(upload=path) | Q(thumbnail=path)
                ).first()
                self.attachments_paths[path] = attachment
            return self.attachments_paths[path]

        return None

    def push_attachment(self, attachment):
        self.result += f"<attachment={attachment.name}:{attachment.id}>"


def update_image(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 2] != "![":
        return False

    label = find_delimiters(state, pos + 1, "[]")
    if not label:
        return False

    url = find_delimiters(state, label[1], "()")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_short_image(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 2] != "!(":
        return False

    url = find_delimiters(state, pos + 1, "()")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_image_bbcode(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 5].lower() != "[img]":
        return False

    url = find_delimiters(state, pos, ("[img]", "[/img]"))
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 5 : url[1] - 6])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_autolink(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos] != "<":
        return False

    url = find_delimiters(state, pos, "<>")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_link(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos] != "[":
        return False

    label = find_delimiters(state, pos, "[]")
    if not label:
        return False

    label_markup = parse(
        state.attachment_type, state.source[label[0] + 1 : label[1] - 1], state
    )
    label_attachments = search_attachments(label_markup)
    label_attachments_ids = set([attachment[0] for attachment in label_attachments])

    url = find_delimiters(state, label[1], "()")
    if not url:
        return False

    end = url[1]
    url_attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])

    if label_attachments and url_attachment:
        state.result += label_markup
        if url_attachment.id not in label_attachments_ids:
            state.result += " "
            state.push_attachment(url_attachment)

    elif label_attachments:
        state.result += label_markup
        state.result += f" <{state.source[url[0] + 1:url[1] - 1]}>"

    elif url_attachment:
        state.result += label_markup
        state.result += " "
        state.push_attachment(url_attachment)

    else:
        return False

    state.pos = end
    return True


def update_url_bbcode(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 4].lower() != "[url":
        return False

    opening = find_delimiters(state, pos, "[]")
    if not opening:
        return False

    args = state.source[state.pos + 4 : opening[1] - 1]
    if args and args[0] == "=":
        args = args[1:]

    args = args or None

    pos = opening[1]
    maximum = state.maximum
    while pos < maximum:
        if pos == "\\":
            pos += 2
        elif state.source[pos : pos + 6].lower() == "[/url]":
            break
        else:
            pos += 1
    else:
        return False

    content = state.source[opening[1] : pos] or None
    if not content:
        return False

    if args and content:
        content_markup = parse(state.attachment_type, content, state)
        content_attachments = search_attachments(content_markup)
        content_attachments_ids = set(
            [attachment[0] for attachment in content_attachments]
        )
        arg_attachment = parse_attachment_url(state, args)
        if arg_attachment and content_attachments_ids:
            state.result += content_markup
            if arg_attachment.id not in content_attachments_ids:
                state.result += " "
                state.push_attachment(arg_attachment)
        elif arg_attachment:
            state.result += f"{content} "
            state.push_attachment(arg_attachment)
        elif content_attachments_ids:
            state.result += f"<{args}> {content_markup}"
        else:
            return False

    elif content:
        if content_attachment := parse_attachment_url(state, content):
            state.push_attachment(content_attachment)
        else:
            return False

    else:
        return False

    state.pos = pos + 6
    return True


def find_delimiters(
    state: ParsingState, start: int, delimiters: str | tuple[str, str]
) -> tuple[int, int] | None:
    source = state.source.lower()

    start_delimiter = delimiters[0]
    start_delimiter_len = len(start_delimiter)
    end_delimiter = delimiters[1]
    end_delimiter_len = len(end_delimiter)

    result = [0, 0]

    pos = start
    level = 0
    while pos < state.maximum:
        if source[pos] == "\\":
            pos += 2

        elif source[pos : pos + start_delimiter_len] == start_delimiter:
            if level == 0:
                result[0] = pos

            level += 1
            pos += 1
        elif source[pos : pos + end_delimiter_len] == end_delimiter:
            level -= 1
            if level == 0:
                result[1] = pos + end_delimiter_len
                return tuple(result)

            pos += 1

        else:
            pos += 1

    else:
        return None


def escape_character(state: ParsingState) -> bool:
    if state.source[state.pos] != "\\":
        return False

    state.result += state.source[state.pos : state.pos + 2]
    state.pos += 2
    return True


def store_character(state: ParsingState) -> bool:
    state.result += state.source[state.pos]
    state.pos += 1
    return True


RULES = (
    update_image,
    update_short_image,
    update_image_bbcode,
    update_autolink,
    update_url_bbcode,
    update_link,
    escape_character,
    store_character,
)


def parse_attachment_url(state: ParsingState, attachment_url: str):
    clean_url = attachment_url.strip()
    if not clean_url:
        return None

    if f"{settings.MEDIA_URL}attachments/" in clean_url:
        return parse_attachment_media_url(state, clean_url)

    if clean_url.startswith("/a/thumb/"):
        clean_url = clean_url[9:]
    elif clean_url.startswith("/a/"):
        clean_url = clean_url[3:]
    else:
        return None

    if "/" in clean_url:
        clean_url = clean_url[clean_url.index("/") + 1 :]
    if "/" in clean_url:
        clean_url = clean_url[: clean_url.index("/")]

    try:
        attachment_id = int(clean_url)
    except (ValueError, TypeError):
        return None

    return state.get_attachment(id=attachment_id)


def parse_attachment_media_url(state: ParsingState, attachment_url: str):
    attachments_media_url = f"{settings.MEDIA_URL}attachments/"

    file_path = attachment_url[
        attachment_url.index(attachments_media_url) + len(settings.MEDIA_URL) :
    ]

    if " " in file_path:
        file_path = file_path.split(" ", 1)[0]
    if not file_path:
        return None

    return state.get_attachment(path=file_path)


ATTACHMENT_ARGS_RE = re.compile(
    r"([a-z0-9]|-|_|\.)+? *: *(?P<id>([1-9][0-9]*))", re.IGNORECASE
)


def search_attachments(source: str) -> list[tuple[int, int, int]]:
    results = []

    pos = 0
    maximum = len(source)
    while pos < maximum:
        if source[pos] == "\\":
            pos += 2

        elif source[pos : pos + 12].lower() == "<attachment=":
            start = pos
            pos += 13
            while pos < maximum:
                if source[pos] == "\\":
                    pos += 2
                elif source[pos] == ">":
                    args_str = source[start + 12 : pos].strip()
                    if args_match := ATTACHMENT_ARGS_RE.match(args_str):
                        try:
                            attachment_id = int(args_match.group("id"))
                            results.append((attachment_id, start, pos + 1))
                        except (ValueError, TypeError):
                            pass
                    pos += 1
                else:
                    pos += 1
        else:
            pos += 1

    return results


class Migration(migrations.Migration):

    atomic = False

    dependencies = [
        ("misago_attachments", "0005_attachment_clean_names_populate_slugs"),
        ("misago_threads", "0017_delete_subscription"),
    ]

    operations = [
        migrations.RunPython(
            update_posts_attachments_markup,
            migrations.RunPython.noop,
        ),
    ]
