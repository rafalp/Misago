# Generated by Django 4.2.10 on 2025-01-17 21:58
import re
from typing import Optional

from django.conf import settings
from django.db import migrations
from django.db.models import Q


def update_posts_attachments_markup(apps, _):
    Attachment = apps.get_model("misago_attachments", "Attachment")
    Post = apps.get_model("misago_threads", "Post")

    queryset = Post.objects.filter(
        Q(original__contains="/a/")
        | Q(original__contains=settings.MEDIA_URL + "attachments/")
    ).order_by("-id")

    for post in queryset.iterator(chunk_size=20):
        update_post_attachments_markup(Attachment, post)


def update_post_attachments_markup(attachment_type, post):
    original = parse(attachment_type, post.original)
    if original == post.original:
        return False

    post.original = original
    post.save(update_fields=["original"])

    return True


def parse(
    attachment_type,
    source: str,
    from_state: Optional["ParsingState"] = None,
) -> str:
    state = ParsingState(attachment_type, source)

    if from_state:
        state.attachments_ids = from_state.attachments_ids
        state.attachments_paths = from_state.attachments_paths

    while state.pos < state.maximum:
        for rule in RULES:
            if rule(state):
                break

    return state.result


class ParsingState:
    source: str
    maximum: str
    pos: str
    result: str

    def __init__(self, attachment_type, source: str):
        self.attachment_type = attachment_type
        self.attachments_ids: dict = {}
        self.attachments_paths: dict = {}

        self.source = source
        self.maximum = len(source)
        self.pos = 0

        self.result = ""

    def get_attachment(self, *, id: int | None = None, path: str | None = None):
        if id and path:
            raise ValueError("'id' and 'path' options can't be used together")

        if id:
            if id not in self.attachments_ids:
                attachment = self.attachment_type.objects.filter(id=id).first()
                self.attachments_ids[id] = attachment
            return self.attachments_ids[id]

        if path:
            if path not in self.attachments_paths:
                attachment = self.attachment_type.objects.filter(
                    Q(upload=path) | Q(thumbnail=path)
                ).first()
                self.attachments_paths[path] = attachment
            return self.attachments_paths[path]

        return None

    def push_attachment(self, attachment):
        self.result += f"<attachment={attachment.name}:{attachment.id}>"


def update_image(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 2] != "![":
        return False

    label = find_delimiters(state, pos + 1, "[]")
    if not label:
        return False

    url = find_delimiters(state, label[1], "()")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_short_image(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 2] != "!(":
        return False

    url = find_delimiters(state, pos + 1, "()")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_image_bbcode(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos : pos + 5].lower() != "[img]":
        return False

    url = find_delimiters(state, pos, ("[img]", "[/img]"))
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 5 : url[1] - 6])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_autolink(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos] != "<":
        return False

    url = find_delimiters(state, pos, "<>")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def update_link(state: ParsingState) -> bool:
    pos = state.pos
    if state.source[pos] != "[":
        return False

    label = find_delimiters(state, pos, "[]")
    if not label:
        return False

    label_markup = parse(
        state.attachment_type, state.source[label[0] + 1 : label[1] - 1], state
    )
    label_attachments = search_attachments(label_markup)

    url = find_delimiters(state, label[1], "()")
    if not url:
        return False

    end = url[1]
    url_attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])

    if label_attachments and url_attachment:
        state.result += state.source[label[0] + 1 : label[1] - 1]
        state.result += " "
        state.push_attachment(url_attachment)

    elif label_attachments:
        state.result += state.source[label[0] + 1 : label[1] - 1]

    elif url_attachment:
        state.result += state.source[label[0] + 1 : label[1] - 1]
        state.result += " "
        state.push_attachment(url_attachment)

    else:
        return False

    state.pos = end
    return True


def update_link_bbcode(state: ParsingState) -> bool:
    return False

    pos = state.pos
    if state.source[pos : pos + 4] != "[url":
        return False

    opening = find_delimiters(state, pos, "[]")
    if not opening:
        return False

    url = find_delimiters(state, label[1], "()")
    if not url:
        return False

    end = url[1]

    attachment = parse_attachment_url(state, state.source[url[0] + 1 : url[1] - 1])
    if not attachment:
        return None

    state.push_attachment(attachment)
    state.pos = end

    return True


def find_delimiters(
    state: ParsingState, start: int, delimiters: str | tuple[str, str]
) -> tuple[int, int] | None:
    source = state.source.lower()

    start_delimiter = delimiters[0]
    start_delimiter_len = len(start_delimiter)
    end_delimiter = delimiters[1]
    end_delimiter_len = len(end_delimiter)

    result = [0, 0]

    pos = start
    level = 0
    while pos < state.maximum:
        if source[pos] == "\\":
            pos += 2

        elif source[pos : pos + start_delimiter_len] == start_delimiter:
            if level == 0:
                result[0] = pos

            level += 1
            pos += 1
        elif source[pos : pos + end_delimiter_len] == end_delimiter:
            level -= 1
            if level == 0:
                result[1] = pos + end_delimiter_len
                return tuple(result)

            pos += 1

        else:
            pos += 1

    else:
        return None


def escape_character(state: ParsingState) -> bool:
    if state.source[state.pos] != "\\":
        return False

    state.result += state.source[state.pos : state.pos + 2]
    state.pos += 2
    return True


def store_character(state: ParsingState) -> bool:
    state.result += state.source[state.pos]
    state.pos += 1
    return True


RULES = (
    update_image,
    update_short_image,
    update_image_bbcode,
    update_autolink,
    update_link,
    update_link_bbcode,
    escape_character,
    store_character,
)


def parse_attachment_url(state: ParsingState, attachment_url: str):
    clean_url = attachment_url.strip()
    if not clean_url:
        return None

    if f"{settings.MEDIA_URL}attachments/" in clean_url:
        return parse_attachment_media_url(state, clean_url)

    if clean_url.startswith("/a/thumb/"):
        clean_url = clean_url[9:]
    elif clean_url.startswith("/a/"):
        clean_url = clean_url[3:]
    else:
        return None

    if "/" in clean_url:
        clean_url = clean_url[clean_url.index("/") + 1 :]
    if "/" in clean_url:
        clean_url = clean_url[: clean_url.index("/")]

    try:
        attachment_id = int(clean_url)
    except (ValueError, TypeError):
        return None

    return state.get_attachment(id=attachment_id)


def parse_attachment_media_url(state: ParsingState, attachment_url: str):
    attachments_media_url = f"{settings.MEDIA_URL}attachments/"

    file_path = attachment_url[
        attachment_url.index(attachments_media_url) + len(settings.MEDIA_URL) :
    ]

    if " " in file_path:
        file_path = file_path.split(" ", 1)[0]
    if not file_path:
        return None

    return state.get_attachment(path=file_path)


ATTACHMENT_RE = re.compile(
    r"<attachment= *([a-z0-9]|-|_|\.)+? *: *[1-9][0-9]* *>", re.IGNORECASE
)


def search_attachments(source: str) -> list[tuple[int, int]]:
    results = []
    for match in ATTACHMENT_RE.finditer(source):
        results.append(match.span(0))
    return results


class Migration(migrations.Migration):

    atomic = False

    dependencies = [
        ("misago_attachments", "0005_attachment_clean_names_populate_slugs"),
        ("misago_threads", "0017_delete_subscription"),
    ]

    operations = [
        migrations.RunPython(
            update_posts_attachments_markup,
            migrations.RunPython.noop,
        ),
    ]
